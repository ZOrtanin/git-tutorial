Всем привет, друзья, с вами Артём. И это выпуск «Про гид» мы начинали. Во-первых, для кого этот выпуск? Если вы только начинаете изучать гид, только лишь погружайтесь тем вот этот выпуск, однозначно для вас. Вы узнаете, что такое гид? Как с ним работать? Как создавать репозиторий? Как создавать комиты? Вы узнаете о витвлении в гид. Вы узнаете, чем ребейс отличается от мерщей и так далее. Мы с вами поработаем в консоли и еще и в сердце разработки. Если пока для вас что-то непонятно, то не переживайте мой цель как раз донести до вас все необходимое, чтобы сразу после просмотра этого выпуска вы могли пользоваться в гид с довольно хорошим уровнем понимания вопроса. Я не берусь здесь освятить все эти мы, но только те, которые действительно необходимы поверти, этого будет более чем достаточно. С другой же стороны, если вы уже знакомы с гид и хотите либо узнать что-то новое, либо освежить старое знание, то тут вы быск также для вас, потому что я учел к вашей пожелания под предыдущими выпусками и сделал PDF, то есть сделал текстовую версию этого выпуска. В нее, конечно же, войдут все абсолютно команды и весь материал из этого выпуска. И плюс я собрал еще в ней те команды, которые я сам иногда использую для решения, скажем так, не стандартных ситуаций, поэтому обязательно досмотрите выпусы до конца, по позже расскажу про этот PDF. И еще учел ваши комментарии, поэтому в выпуске будет довольно много визуального сопровождения. Ну что ж, поехали! Что такое гид? Гид – это одна система контроля версии, version контрол-систем, VCS. VCS – это система с помощью которой мы фиксируем изменения и при необходимости можем вернуться к определенной версии. Плюс – в ней мы можем оследить всю историю изменения. И хотя в видео мы будем подразумевать что эта система управляет файлами с исходным программным кодом, стодержать в голове, что в общем случае это могут быть любые файлы. Сразу может возникнуть вопрос, зачем она нужна? Разберем, например, их. Первый довольно синтетический. Представьте, вы работаете один над проектом без системы контроля версий. В определенном момент сделала какие-то правки подливы на сервер, вы понимаете, что что-то пошло не так. Такой ситуации не имея никакой возможности быстро козеризменения и продюсся вручную править часть кода и восстановить работу сервера. Другую пример уже более реальный. Вы работаете в одной из команд над общим проектом. Каждый команда работает на своим новым функционалом. Начали работы у каждой команды по сути абсолютно идентичной копии проекта. По окончании же работы у каждой из них получается продукт уже снова в функционалом, только без того, что дело другая команда. И вот тут возникает вопрос. Как все это объединить без системы контроля версий? А если команда частично правили одни и те же файлы проекта, в этой ситуации вопрос еще сильнее усложняется, и это только часть проблем при работе над проектом. Первое, что приходит в голову для решения некоторых из них, это создавать полные копии проекта с течением времени. Адельные папки. Возможно, с какой-то помидкой. Но это как минимум неудобно, да и не особо хорошо решаем даже эти проблемы, которые я описал выше. Не буду долго томить. Для решения этих и многие других вопросов как раз и были придуманы системы контроля версий. Глобально их можно разделить на централизованные и распределемные. Как вы понимаете, чаще всего большие проекты пишут несколько людей от той команд, которым нужно как-то взаимодействовать между собой в плане передачи кода. Централизованная системы контроля версий решает эту задачу. Такой схеме имеется один центральный узел, где хранятся все файлы проекта. И несколько клиентов, которые получают информацию с него. Обращаем внимание. Полная история проекта находится только на удалённом сервере. Когда кто-то вносит изменения в код и фиксирует их, все через центральный узел получают уже обновленный код. Все просто. Какой-то самый очевидный минус. Гедина. Если что-то случилось сервером, то как минимум на то время, пока мы будем разбираться с проблемой, работа разработчиков может стать. Расподелённый вес есть. Не обладает такими достатками. У каждого разработчиков, локально, находится проект с полной истории всех изменений в проекте. И даже если есть центральный сервер, где также находятся полные при истории проекта. И он недоступен, мы все равно можем как минимум фиксировать изменения в проекте и взаимодействие напрямую. А после того, как работа центрального сервера будет восстановлено, мы можем перенести все правки туда. Такой схеме мы полностью независим от удалённого сервера. Гидко-крас и является распределённой системой контроля версии. Как он работает с данными, в чём его отличие от других систем? В общем, работу большинства других VCS можно представить так. У нас есть проект с файлами, которые дальше мы будем называть репозиторию. Каждый раз, когда мы вносим правки фиксируемых, система запоминает это и хранит сами исходные файлы и список изменений к ним. По сути, по прошествии какого-то времени каждый файл в репозитории при таком подходе представляет собой исходный файл, на который один за одним накладывается изменение. Всё просто. Гид управляет данными, совершенно иначе. Каждый раз, когда мы сохраняем состояние проекта, Гид запоминает, как выглядит каждый файл в этот момент времени, как бы делая снимок всю проекту, замораживая его. Гид сохраняет ссылку на этот снимок. По-другому ещё его можно назвать комит. Если какие-то файлы в этот раз не были изменены вовсе, то для эффективности Гид не запоминает эти файлы снова, а просто подтягивает ссылки на предыдущие версии этого файла и из предыдущего комита. Получается, что в Гид хранится набор вот таких комитов, которые связаны между собой с ссылками. Каждый комит ссылается на какой-то предыдущий формируя тем самым цепочку, по которым мы можем ослить всю историю проекта. Логичный вопрос. Что это за ссылки, которыми связаны комиты, как и не в общем формируется? Вот тут нужно сделать небольшое ступление и понять, что такое хэш-функция. Не пугайтесь, всё довольно просто. Возьмём, например, обычную функцию с ажкольного курса, а у равно 2x. Здесь x – это аргумент функции или входные данные, а у – результат или значение функции. А противимнимание, имея х, мы всегда можем вычислить у, а у – можем вычислить х. Всё просто. С хэш-функции всё немного иначе. Имея входные данные, мы относительно просто можем вычислить значение или хэш-суму. Но вот имея только результат, либо очень трудно, либо невозможно вычислить какими были входные данные. Ещё одна особенность – это длинна хэш-сум. Возьмём хэш-функцию s и чей ван. Её хэш-сум всегда равна 160 бит или 46-ти ричных чисел, не больше, не меньше. Очень важный момент. Если в качестве входных данных взять, например, сценария этого ролика, будьте с ль-с-h-i-1 хэш-суму, то мы получим какое значение. Если же теперь я измерю в сценарии, хоть один символ или даже один бит, и снова вычислить хэш-суму, то несмотря на то, что изменения были небольшими, результаты будут совершенно разными. Хорошо, но как это вообще связано с гидц-спросите вы? Самым, что не на есть прямым образом. Каждый раз, когда вы делаете комит, гидц начала вычислять хэш-суму этого комита, и только потом сохраняет информацию. При этом комить и ссылка на предыдущий комит. Его хэш-суму. Так, гид обеспечивает целостность истории изменений. И даже если кто-то, хоть что-нибудь изменит в любом комите и сыпочке, его хэш-суму полностью изменится и придется переписывать уже всю последующую историю комитов, что не останется незамеченным. Что ж, давайте пока передохнем от теории и что-нибудь поделано жоруками. Оночать можно, конечно же, с установки. Если у вас, например, Макоз, то вам достаточно установить их скот, там уже будет гид. Если у вас линок, что вы можете выполнить в терминале о команде Upt Install Gid. Если же Windows, то переходим на сайт, в раздел Download, скачиваем установчик и запускаем его. Процесс на самом деле очень простой, просто нажимаем везде далее, далее, далее. Вбираем здесь стандартные параметры по умолчанию и по завершению установки в любой папке. Нажимайте правую кнопку мыши и выбирайте гид баш хэй. И у вас открывается практически та же самая команда строка, что сейчас будет у меня. Но почему бы сразу не разобрать какой-нибудь графический интерфейс вместо того, чтобы сейчас что-то изучать в консоли? На самом деле все просто, друзья. Графические интерфейсы для гид довольно-таки много. Если необходимо, вы можете их найти в интернете и попробовать по пользу с ними. Но важно понять, именно, как работать в консоли, важно понять саму логику работы с гид. И если вы это поймете, то потом завтра, если вы или какой-то новый графический интерфейс для гид, вы с лёгкостью его изучите и начнёте использовать. Опять же, если вам будет необходимо. Но сейчас, как бы, я не вижу смысла разбирать какой-то конкретный графический интерфейс и рассматривать за что-то отвечает команда строка. Как я уже сказал, гораздо важнее понять саму логику работы. От себя могу сказать, что я вообще графическими интерфейсами и такими не пользуюсь, потому что я работаю в среде разработки всегда для Java, это Intel GID, а для Python, это PTR. И там просто прекраснейшая интеграция с гитом. И вот всё, что там есть, мне это достаточно. И опять же, если с учетской ситуации что я не могу что-то сделать прямо среди разработки, я прямо там открываю терминал, консоль и выполняю какие-то команды. Опять же, я иду в консоль, выполняю какие-то команды для меня, это намного быстрее, как это не удивительно. Работа через консоль для меня быстрее почему-то. В общем, открываем консоль и нам нужно сделать первоначально настройку, которая не сложнее в установке, на самом деле. Нам нужно указать всего лишь три вещи. Имя пользователя, его и Mail, эта информация она будет отображаться в комитах. И текстовый редактор по умолчанию. Для того, чтобы нам работать с конфигурацией, у гит есть утилита, которая так и называется, гит-конфик. И ещё в гит есть, скажем так, три уровня конфигурации. Первое, которое покрывает всех пользователей системы. Для этого нужно выполнить гит-конфик с флагом minus-minus-system. Второе, второй уровень, это настройки, которая будет применяться к пользователю системы, конкретному пользователю системы. Для этого нужно выполнить команду гит-конфик minus-глобл. И треть уровень, который будет применяться конкретно вот к текущему репозиторию, с которым вы работаете. Для этого нужно выполнить просто гит-конфик, либо гит-конфик minus-minus-local. Всё довольно просто. Я выберу глобл, то есть настройки будут применяться прямо вот ко всем репозиториям конкретно для данного пользователя в системе. Значит, водим команду, гит-конфик minus-глобл, дальше user.name и дальше соответственно, ваша имя пользователя. Нажимаем Enter. И ещё водим вот такую команду, гит-конфик minus-minus-local, user.name и мое. Ну и дальше, соответственно, водим вашим mail, нажимаем Enter. Текста-вредактор можно будет выбрать при первом комите. Поэтому оставим пока что это на потом. Я всегда, кстати, использую вим. Теперь до того, чтобы нам вообще было с чем работа, давайте создадим отдельный каталог. И в нем уже будем выполнять все эти команды. Я это сделать через консоль, если вам это неудобно, то вы можете просто в проводнике, если у вас Windows, давай кнопкой, создать новая папка. Я же выполню команду mkdir, создание каталога, и назову его просто гит. И перехожу в него, сидим, гит. Для того, чтобы посмотреть, какие файлы и папки есть каталоги, можно выполнить команду ls и передать ей два полезных аргумента minus l, minus l вы видите файлы и папки видя списка, а minus a означает, что отобразить все скрытые файлы и каталоги. Как видим, у нас здесь пусто. Для того, чтобы нам создать вообще сам репозиторий, нужно выполнить команду gith. И нит. И обратите теперь внимание, если я выполнив опять команду ls minus l, то я увидю, что внутри каталога создалась папка точка gith. Вот как раз там и хранится вся история нашего проекта, скажем так. При этом абсолютно неважно. Были у вас какие-то файлы в этом каталоге или нет, если вы уже, например, работаете над каким-то проектом и хотите подключить систему контроля версий, то также захоте в этот каталог выполнять команду gith. Теперь давайте я создам какой-нибудь файл, пусть даже пустой. Для того, чтобы создать вообще пустой файл, вот частности блинокси, можно выполнить команду tatch. Опять же, винда все, можете правой кнопкой создать текстов документ, например. И давайте я его назву up.app.py. Как посмотреть нам теперь историю изменений, понятно и сделано, мы не только что создали проект, там, навряд ли что-то будет, но все же. Для этого есть простая команда, которая называется gith.log. Выполняем gith.log и мы видим, что у нас есть такое сообщение, что пока что у нас в истории ничего нет. Пока что не обращайте, пожалуйста, внимание на то, что здесь написано витком мастере, и так далее, нас пока что на данном моменте интересует то, что в истории у нас ничего нет. Есть одна еще очень полезная команда, которая многозначная, она, скажем так, показывает статус всех файлов, что всякую состояние вашего проекта, ну и так далее. Мы ее подробнее рассмотрим. Называется на gith.status. Довольно таки просто все. Выполаем команду gith.status. Здесь опять же, мы все подробно разберем, но только чуть-чуть позже. Нас интересует пока что вот это вот надпись. Обратите, пожалуйста, внимание, gith нам говорит, нас он это to commit, but on track file present, you'll get it to track. То есть нам gith говорит, что нечего добавлять в commit, но есть какие-то on track files. И он нам говорит, и используйте команду gith.at для того, чтобы начать track.at file. Вот тут нам очень важно понять, в каких состояниях могут быть файлы внутри гита. Давайте подробно рассмотрим этот момент, потому что это очень важно для для нашего понимания. Файлы в рабочем каталогии могут быть под версионом контролем, то есть отслеживаемый, track и неподверсионом контролем. Untracked. Зачем это нужно? Как правило, в папке с проекта могут оказаться временные файлы. Ну, логи, например, которые вообще не нужны в репозитории, поэтому их отслеживать не обязательно. Если с последними все просто, мы их не берем во внимание все, то вот со вторыми давайте разбираться. Мы сохраняем, удаляем, изменяем какие-то файлы. Затем, комитим, то есть делаем снимок нашего проекта, и gith запоминает это состояние. Далее, крупов теряется, а гид накапливает таким образом историю изменений проекции. И если будет необходимо, gith может откатить состояние нашего проекта на любой комитт. Тут мы можем заметить два состояния файла, в котором он может находиться. Когда файл был только изменен, но еще не попал в комитт, он находится в состоянии, модифайт или измененный. После комита, когда gith уже сохранил состояние проекта, файл переход в состояние, комитет или зафиксированные. Потом файл может снова перейти в состоянии модифайт, если его изменить и круг повторится, все довольно просто. Если взглянуть немного ближе, мы увидим, что есть еще одно промежуточное состояние, в котором может находиться файл, стейчт или подготовленная комитту. А область, в которой находятся такие файлы, называют стейджен-эрре, или область подготовленных файлов, или просто индекс. Что это такое? На самом деле нельзя просто изменить файл и тут же сделать комитт. После того, как вы или создадите новые файлы, или изменить и какой-то существующий, нужно выполнить команду gith at, и указать либо конкретный файл, либо целую директорию. Тогда все файлы мне попадут в стейджен-эрре. И вот только потом можно выполнить команду gith comit, и, например, через флаг минус m сразу передать так называемый comit message. Небольшой описанят того, что было изменено в рамках этого комита. Это сообщение будет отображаться в истории и будет проще понимать по сообщению, что было исправлено. Если не указывать этот флаг, то откроет стекста редактор для вода этого комитт меч. Теперь файл перешел из состояния стейджт вы комитет. Вопрос. Зачем так усложнять? Не взят проще. Изменил, закомитил. На самом деле, это только кажется на первый гляд, что это некоторое усложнение. Давайте рассмотрим на конкретном примере. У вас есть какой-то проект в нем довольно много файлов. Вы увлеклись работой и сделали довольно много правок. И теперь понимаете, что было бы очень здорово разделить вот эти правки на 2, а той на 3 комита. Конечно, вы можете взять все ваши правки, заслывать в 1 комита, громно написать здоровенное сообщение и на этом остановиться. На уровне gith, в принципе, нет каких-то жестких требования на эту тему, но так делать не стоит. От себя могу сказать, что лучше сделать 2, 3, 4 маленьких комита с короткими, понятными сообщениями, не жили чем 1 здоровый с огромным каким сообщением. Вот вы сделали много изменений, хотите разбить их на 2 комита. Как это сделать? Очень просто. Берем файлы для первого комита и выполняем gith et только для них. А потом выполняем gith comit-m и указываем какую-то сообщение. Готово. Теперь берем остальные. Выполняем gith et для них и выполняем gith comit-m и снова какой-то короткое сообщение. Теперь в gith есть 2 комита, довольно понятными короткими сообщениями, по которым можно понять, что была и именно измениновывая в рамках этого комита. Как видите, в плане команд нет абсолютно никаких сложностей, когда перейдем еще к среде разработки, вы увидите, что там это делается вообще еще быстрее. Как посмотреть, какие файлы в каком состоянии находится. Очень просто для этого выполняем тоже команду gith status. Как видим, наш новосознанный файлик ap.py находится как раз в intract files. Для того, чтобы добавить его в индекс, выполняем команду gith et appy. Снова выполняем команду gith status и мы видим, что у нас появилась такая строка изменения для комита. И мы видим здесь новый файл ap.file для того, чтобы закомнить, выбираем gith comit-m и какой сообщение. Готово, теперь давайте рассмотрим некоторые команды. Во-первых, уже знакомая нам команда gith-lock, она отображает нам комиты, которые есть в истории. Вот у нас хэш сумма этого комита, вот автор этого комита, его e-mail и так далее. И, соответственно, короткое сообщение. Если мы возьмем, например, команду gith-show, она, скажем так, многогранная. В зависимости от того, что и передачу в качестве гумента, она будет изменять свое поведение. Вообще, она показывает какой-то объект, показывает его в какие-то подробностях. Например, если я передам команде gith-show, хэш комита, то, соответственно, она отобразит более детально, что это был закомит. Ну, здесь мы видим, опять же, во-первых, сообщение этого комита. И что было сделано в рамках этого комита? Ну, я здесь вижу, что был добавлен новый файл, который называется ap.py. Вот он у нас пустой, то есть, если я его откровен, например, тем же вимом, да? ap.py он у нас пустой. Кстати, многие не знают, как выйти из вим. Делаться на самом деле очень просто, и, значит, нажимаем escape, а дальше водим 2.x. x он, что сделан, он сохранит файл и выйдет из него. Например, есть полезный еще параметр w, он просто лишь без выхода сохранит изменения. а q выйдет из документа, но при условии, что вы ничего не поменяли. Если вы что-то изменили и ведете q, то он вас предупредит, что вы точно уверены, что хотите выйти. Правчики-то есть. Вот я выбираю x, выхожу. Дальше есть такой полезный аргумент для команды gith-log – minus p. Он просто выведет у нас комитт с более подробным выводом. То есть здесь у нас помимо сообщений, еще будет отображаться кратенько, что было сделано в рамках этого комита. Ну, как мы уже увидели, здесь просто был добавлен новый файл. Еще одна очень интересная команда, которая называется gith-рестore. Что она делает? По сути, она откатывает изменение файли на состояние последнего комита. А чем идет речь? Давайте я, например, открою файл ap.py И здесь напишу какой-то код. Print. Ну, что самое банальное, да? Hello World. Да? Кстати, для того, чтобы начать что-то редактировать, нажимаем кнопочку a и дальше у нас есть возможность редактировать документы. Нажимая escape, 2.x. Кстати, давайте выполним команду gith-status. Обратите внимание, документ перешел состояние modify. Я имею в виду app.p. И теперь смотрите. Получается, что я изменил файл ap.py. Если я хочу его вернуть на состояние последнего комита, ну, например, я сделал какие-то правки, понимаю, что они ошибочные. Я могу выполнить gith-рестore и дальше передать ей ap.py. Все. Давайте я теперь открою ap.py и смотрите. Состояние файла перешло на то, которое было на момент последнего комита. Ну, а на момент последнего комита файл был пустой. Еще одна очень полезная команда, которая называется gith-dif. Dif это сокращение дефиренц. По сути, она показывает какие изменения были внесены файл с момента последнего комита. Ну, например, вернемся опять к тому же файлу ap.py. Давайте здесь ведем print. Просто print. Да, сохраняем выходим. Бодим команду gith и нам показывают, смотрите, что в первых у нас есть какие-то изменения, потому что если бы не было, то было бы просто пустой вывод этой команды. Во вторых, смотрите, изменение ap.py, что было добавлено. Плюсиком отображаются отея и состояние изменения, которые были добавлены, минусом, которые удалины. Например, удалили к путь строку, она здесь появится за знакоминус. И мы видим, что здесь был добавлен print, ну, вызов функции print, без аргумента. Смотрите, выполним снова gith-status. Если мы добавим этот файл windex, да, вот у нас теперь изменение для комита. Если же я теперь выполню команду gith-div с таким полезным аргументом minus-minus-tached, то gith нам теперь выведет изменение, которое уже находится в индексе. Если я просто выполнил команду gith-div, без каких аргументов, то она ничего нам не выведет. Потому что все эти изменения, которые мы сейчас делали, а именно ap.py, они уже в индексе, и для того, чтобы нам посмотреть какие изменения у нас, и если неподресно, в индексе, то есть подготовлены для комита, нужно выполнить команду gith-div minus-minus-tached. Давайте закомните муча изменения. Я веду команду gith-comit и веду какой-то комит-мессич такой многозначный дефакторинг. Теперь, если подкрыть команду gith-lock, то я уверен, что у меня уже два комита. Если дело очень интересный параметр, который можно передать команду gith-comit, смотрите. Выполним команду gith-status. Gith-status, да? Мы видим, что у нас ничего добавлять комит. Давайте изменим наш файли. Кап.py. И здесь в print-е выведем какую-то строку. Сохраняем, будем gith-status. Мы видим, что у нас есть файлик, в состоянии модифайт. Ап.py. По идее для того, чтобы у меня его закомить, мне, опять, нужно выполнить. Gith-at. Ап.py. Но есть, скажем так, некоторые сокращения. Можно выполнить сразу команду gith-comit и передать ей конечно же minus m, но еще можно передать a. a означает взять все файлы, которые под версионным контролем, и которые были изменены, и добавь их в индекс. Но, по сути, такой выполнник команду gith-at. Только там где-то под капотом. Ну а m, соответственно, давайте верем комит-мессыч. Теперь гит-лок у нас есть уже 3 комита. Есть еще одна полезная команда, которая называется gith-at. mb это сокращение от му, по сути. С помощью нее мы можем либо периминовать файлы, либо перемещать их в каталоге какие-то другие. Но, например, смотрите gith-at.py, выбираю изначально файл.ap.py и я хочу его периминовать, например, в application. В application.py. Для этого можно выполнить gith-mb, ap.py и дальше передать новое имя для этого файлика. Если я хочу, например, перенести этот файл другой каталог, я могу выполнить примерно следующие. Например, выполнить в команду таким образом, я, по сути, перенесу ap.py в каталог resources и мало того, что я его перенесу в каталог. Я его еще и периминую. Но у меня каталога resources нет, поэтому я просто периминую в applications. Давайте посмотрим гид-стратус. И мы видим, что у нас есть изменение для комита. Причем обратите внимание, выполняю gith-mb, гид сразу, где-то там под капотом, выполняет gith-at. Скрывает это как бы от нас. Что довольно удобно. И мы видим, что произошла операция rname, периминование ap.py в application.py. Давайте закомить им. gith-commit. Еще одна полезная команда, которая называется гитарем. Гитарем это, по сути, сокращение трему, то есть удалить. В качестве аргумета можно передать, например, имя файлы. Все довольно просто. Если я выполнен так к команду, если выполнить теперь к команду gith-status, то я увижу изменение, да, а именно удаление файла в application.py. Но самое главное, смотрите, если я выполню ls-manus.ly, то есть посмотрю, какие файлы есть в каталоге, то я увижу, что еще изменение даже не закомитьил, хоть они и вынгся уже, да, но файл был уже удален. Иногда ну, на немного другое поведение этой команды, например, удалить файл в комите, но при этом оставить его в каталоге. Для этого есть один очень интересный аргумент, который можно передать этой команде. Для начала давайте, кому отменив эти изменения, что мы сделали, то есть удаление файла application.py. Здесь, кстати, есть довольно-таки хорошие подсказки, которые есть, в принципе, всегда, когда выполняйте gith-status, да и не только на самом деле. Нам говорят использую gith-restaur minus-stage и дальше передать файлы, для того, чтобы отменить эти изменения. Мы уже говорили, что рестore отменяет изменения, которые вы внесли файл, но еще файл этот не попал в индекс. Так вот, если вы внесли изменение файлы, уже его добавили в индекс, для того, чтобы отменить это изменение. Можно выполнить gith-restaur и передать ему minus-stage. Давайте это сделаем. gith-restaur minus-stage. И дальше передадим вот этот файлик. Смотрите, что получилось. У нас файл улетел из индекса, то есть он больше не в индексе, да? И теперь я выполню команду gith-restaur application.py. Все, теперь у нас нету никаких gith-status. Нету никаких изменений для комита, да? Но и сам файлик у нас появился в каталоге. Так вот, мы говорили про команду gith-restaur. Вот, выполняем gith-restaur minus-stage. И application.py. Передаю. Смотрите, что у нас произошло. Выполняем gith-status. У нас первое есть изменение для комита. То есть, в индексе у нас есть операция delete, что именно удаляло с application.py. Но у нас есть еще антрект files application.py. То есть, если я выполню команду ls, то я увижу, что у нас есть этот файл, как бы он никуда не ударился из рабочего каталога. И если я выполню gith-comit, да, передам, передам commit-message. Application.py. В гитлоге у нас появился этот comit, да? И в каталоге у нас есть этот файл. При этом, если я выполню команду gith-status, то я увижу, что файл у нас появился в категории antract files. Все довольно просто. Теперь я хочу рассмотреть один очень важный момент, который для многих поначалу может быть далеко не очевидным. А чем идет речь? Давайте мы снова добавим этот файл gith-resta application.py. Ну, здесь он нас перейдет в индекс, да, как новый файл, ничего нового. Давайте посмотрим, что у нас внутри этого файла. Ну, и здесь собственно то, что мы писали, вызов функции print и так далее, да? Теперь еще раз выполним команду gith-status. Смотрите, он у нас есть файл этот в индексе. Теперь после того, как мы добавили его в индекс, давайте мы его поменяем. Как-то изменим. Ну, давайте вызовем еще одну функцию. А... Еще одну функцию print, да и сохраним. И снова выполнить команду gith-status. И что мы тут видим? Мы видим, что один и тот же файл. Application.py у нас есть изменение для камиды, то есть он попал в индекс. И он же у нас отображается, как будто он в состоянии модифайт. Что это означает? Смотрите, когда вы изменили файл, и после выполнений gith-at, файл, соответственно, попадает в индекс. Это означает, что gith запомнил состояние файла на момент выполнения команда gith-atus. Далее вы можете файлы, изменить еще раз, изменить его дважды, удалить его и все прочее. Если вы выполните команду gith-commit, gith закомите только то, что попало в индекс, а в индекс попало только наше первое изменение. Понимаете? И получается, что если я сейчас выполню gith-commit, да, передам какое-то сообщение, то закомите только то, что был создан новый файл. Так вот, если вы сделали выполнение gith-commit-at, дальше вы вспомнили, что нужно что-то дополнить файл, вы правите этот файл, и вам нужно снова добавить этот файл в индекс. И gith, как бы обновить состояние, то есть он запомнит текущий его состояние. Вот смотрите, выполняю снова gith-at, application-py. Если я снова выполню команду gith status, то я увижу, соответственно, что файл только в индексе. Давайте выполним команду gith-commit-m. Да, давайте посмотрим gith-lock, и вот он наш последний комитт. Если мы теперь посмотрим, что было изменено в рамках этого комита, да, выполним команду gith-show, то смотрите, у нас добавился новый файл, и в нем добавилась две строки. Еще один важный нюанс, который также полезно знать. Смотрите, иногда в рабочем каталоге могут скабливаться какие-то файлы, которые вы в принципе не хотите комитить, они не нужны в репозиторе. Но и каждый раз их видеть в категории antract files, тоже как-то не особо удобно. Это могут быть, например, какие-то логие, какие-то временные бинарные файлы, что угодно, что-то временное, что в принципе в репозиторе, как бы не нужно добавлять. Для того, чтобы решить этот вопрос, в гид есть один очень полезный механин, который называется gith-ignore, о чем улетречь. Можно создать специальный файл внутри репозитория, и определить нем некоторые паттерны, некоторые шаблоны. Если имя файлы попадет под этот шаблон, то гид будет просто игнорировать этот файл. Он просто не будет его замечать. Как все это выглядит на практике? Ну смотрите, давайте мы создадим каталог внутри нашего репозитория log, и внутри log создадим файлик, который так и будет называться log-txt. Кстати, для того, чтобы перейти на каталог выше, то есть мы сейчас находимся внутри log, для того, чтобы нам перейти на каталог выше, просто выполняем сиди и две точки. Давайте выполним gith status, и видим, что у нас есть antract files, но целая папка log. Да? Добавляем файлик прямо в внутри нашего репозитория, который так называется точка gith. gith. И я здесь заготовил некоторые шаблоны уже. Давайте на них посмотрим, во-первых, в этой две строки это комментарии. То есть, таким образом, можно обозначить комментарии. Далее здесь указано, что gith не будет обращать внимание на целую папку, который называется PyCash. По сути, кстати, вот эти все строки являются упрощенными регулярными выражением, поэтому можно использовать некоторые специальные символы. Как то? Звездочка. 0 или более любых символов каких-то. Если я обозначу какую-то последовательность квадратных скопках, то это будет означать любой символ из этой последовательности. То есть, вот эта строка говорит нам, что gith будет игнорировать file с любым именем, у которого расширение, PyC, PyO и PyD. Все эти файлы будут имерировать с китом. Дальше у нас здесь конкретно file, докер компус яму, будет игнорироваться. Целая папка log, и еще папка, точнее, не папка, а fileproducts.json внутри каталога ресурсов. Сохраняем, выходим. Теперь мы планяем gith status. Видим, что у нас папка log пропала, но появился file gith игнор. Да, его нужно именно добавить в репозиторе, поэтому мы планяем gith. gith. gith. gith. comint-m. и это gith. Ну, теперь мы планяем команду gith status. Как видим изменения у нас нету. Давайте мы создадим, например, здесь file-docker-composs-jamu. Как видим, у нас file-адет есть. Выполняем команду gith status, а у нас никаких изменений нету. То есть, git просто теперь игнорирует этот file, почему? Потому что мы так захотели. Это очень хорошее практику, когда бы в самом начале разработки, вы каталог с проектом, положите вот такой вот file gith игнор. Ну, и соответственно, закомидите его, прям в самом начале. Потому что это поможет, в будущем, избежать ошибок, плане того, что вы добавили случайно там, комит какой-то лишний file. Его, в принципе, вручную, писать не надо, потому что когда мы перейдем к среди разработки, вы увидите, что она сама умеет генерировать вот такие вот file, под какой-то определенный язык, под жау, под гоп, под пайтом, и так далее. Вот, в принципе, вручную его описывать не так уж и нужно. Перед тем, как идите дальше, давайте подытожим. Что мы узнали в этой части ролика? Первое, что нужно сделать после установки gith, и нужно это сделать только один раз, настройте имя пользователя и его и мэйл, которая будет отображаться в комитах. Делается это так. Создать репоситуре gith можно команда gith и имеет каталоги с проектами. Теперь файлы, они могут находиться под версионным контролем и нет. И состояние untracked, после выполнения команда gith add, файл сразу попадает в staging area. Выполны в команду gith commit, мы переводим файл в состоянии comit. То есть, фиксируем изменения в байзе gith. Затем файл может быть снова изменён, перенесён в индекс, после чего снова делаем комит. Хорошо. До этого момента мы с вами рассматривали только лишь линейный процесс, когда комиты шли один за другим, формируя как бы прямую линию. Но в gith есть с одной стороны очень простое для использования, но с другой стороны очень мощным механизм, который позволяет делать более сложные цепочки комитов. Что это? Зачем мы как сейчас поговорим? Вообще, во многие системы контролеверсии так или иначе реализовывают обитвление. А чем мы ретречь? Помните, команду gith status? Первая же строки ее вывода было указано, он branch master. Что это такое? Давайте вспомним, как выглядит цепочка комитов. Каждый комитт селается на предыдущий. В качестве ссылки выступает хэш сумма комита. При таком подходе не сложно догадаться, что, знаю, какой комитт был последним, мы можем осленить по цепочке в обратном направлении все комитты до самого первого. Все просто. Вопрос. Как быстро узнать, какой комитт последний? Без просчета всех ссылок. Для этого в гид есть специальный указатель. Эт? Это просто метка, которую указывает на какой-то комитт. По ней гид и понимает, в каком состоянии должен находиться проект вашим рабочим каталоге. Каждый раз, когда мы делаем комитт, этот указатель автоматически смещается со старого комита вперед на новосознанный. Где его можно увидеть? А давайте откроем команду githlock. Смотрите, вот это наш последний комитт. И здесь мы видим, что у нас хед, во-первых, он стоит на этом комите, и он же, в свою очередь, еще указывает на мастер. Да, хед может указывать не только на конкретный комитт, но еще и на ветку. Так вот, в гид ветка – это тоже просто указатель на комитт. Когда мы находимся на какой-то ветке и делаем комитт, указатель этой ветки вместе с хеан передвигается вперед. Я только что сказал на какой-то ветке, за что их может быть не одна, верно. А зачем нам ее указатель хед и еще указатель ветки? Давайте разбираться, например. Пусть вы работаете над проектом. За какое-то время накопилось некоторая история, то есть уже есть какие-то комиты. Тут вам голову приходит новая идея, которую неплохо было бы реализовать в этом проекте. Хорошее практика – это отвести новую ветку и продолжить уже работу в ней. Делается это просто, команды githbrunch newapy. Что изменилось? Да и пока что не так уж и много. Просто теперь на один тоже комитт указывает и ветка master's head и ветка newapy. Мы создали эту ветку для того, чтобы работать в ней. Поэтому давайте переключимся на нее. Делается это просто, команды gith check out newapy. Сейчас тоже особо ничего не поменяло за исключением того, что теперь указатель head ссылается на ветку newapy. Коть мы остались на том же самом комите. И вот тут самое интересное. Сделал какие-то правки в коде, вы делаете новый комитт. Еще и еще сколько будет нужно. Посмотрите, что произошло. Указатель ветки master никуда не сместился. Он как был на этом комите, так и остался. А вот ветка newapy ушла вперед. И теперь содержит новые правки, которых еще нет в master. Более того, если вы снова выплываете команду gith check out master, во-первых, указатель head перейдет на ветку master с соответствующим комитом, а во-вторых, в состоянии файла вашем рабочем каталоге вернется на состояние вот этого комита. То есть правок из этих комитов файла в рабочем каталоге не будет, потому что они не часть ветки master. Вы можете снова перейдутся на ветку newapy, и состояние ваших файла вернется на состояние вот этого комита. Теперь во время работы на одномом опи вы вдруг понимаете, что ветки master в коде есть ошибка, а ваш проект уже работает где-то на сервере. Нужно срочно поправить все это дело. При этом вы понимаете, что и новый apy вы еще не закончили. В случае gith это вообще не проблемы. Приключаемся на ветку master, правим, код, комитим. Смотрите, теперь указатель head вместе с master. Раздрился вперед на новый комитт, которого нет в ветке new apy. Вы передаете код на сервер, там все работает прекрасно, вы градуйтесь и продолжаете работать свои ветки new apy. Не могу сказать, что это какой-то жесткое требование, но тем не менее многие придержутся простого принципа. В master всегда находится стабильный от тестированный код, который в любой момент можно взять, развернуть на сервере, собрать там какой-то образ на слоем вашем коды и так далее. Все же другие разработки ведутся в отдельных вирках, кто например девела или каких-то других. В мастере всегда находится рабочий от тестированный код. Хорошо. Пусть вы отвели ветку и в определенный момент заканчиваете разработку нового функционала. Параллельно вы и возможно переключали что-то поправить, но ваши правки требовали чательные проверки, поэтому вы решили и исправление делать в отдельно ветке. Что, кстати, тоже является хороший практикой. Вы переключились на ветку master и отвели от нее новую, которую назвали bug fix. В ней также появились комиты, со справлениями, которых пока нет в мастер. А дальше это что? Это отдельные ветки. Вот этих правок нет в мастер. Наверняка, что должен быть какой-то механизм, который позволит следить и ветки в одну. Конечно, и первая из них это git merge. Merge – это слие не веток. И упрямняет тогда, когда нужно объединить ветки. Все логично. У нас есть две ветки для мержа bug fix и не вапи. Задача – вмерить их обе в мастер. Давайте начнем в светке bug fix. Для этого переходим на ветку master. git checkout master. Кстати, для того, чтобы посмотреть, какие вообще есть ветки в репозиторе, можно выполнить команду git branch – minus a. Вот он, кстати, ветка bug fix. А вот таким значком означается то, что мы сейчас находимся на ветке master. Ну, это и плюс видно еще команду git status. Итак, выполняем git merge. bug fix. Здесь нам говорится об изменениях, которые прилетели в мастер из ветки bug fix. Но сейчас обратите, пожалуйста, внимание на вот эту фразу – fast forward. Что это значит? Смотрите, до мержа история комита была вот такой. Давайте рассуждать по простому. Как забрать комит из bug fix в мастер? Да просто передвинуть указатель master в период. Это возможно, потому что комит, на который указывал мастер. Г является прямым родителем для ветки bug fix. Тут нет никаких витлений по пути, прямая линии. Это и есть fast forward. git в данном случае упрошает процедур мержа просто передвинуть указатель master в период. Ну а что, собственно, еще делать-то? Теперь ветка bug fix нам больше не нужна, ее можно удалить. git branch – minus d – bug fix. Кстати, если вы создадите ветку, поработаете в ней, создадите там какие-то комиты, и затем попытайтесь ее удалить не смержик, не в одну другую ветку. Не обязательно мастер. То получите примерно вот такое сообщение. То есть git говорит, что ветка девелоп никуда не смержен, поэтому если вы точно хотите ее удалить, то нужно выполнить то же самую команду только с d – большой. Вернемся к нашим мержам. Теперь история выглядит вот так. Нам осталось смержить ветку не лапи в мастер. Обратите внимание, сейчас досление светка не лапи, мы не можем просто так передвинуть указатель мастер вперед. Потому что в таком случае, вот эти комиты останутся весеть без ветки, и в истории мастер не будут видны вообще. Комит, на котором стоит указатель мастер, не является прямым родителем для неуапин. Тут будет работать какого-то другое механизма, хоть и в плане комат для нас отличий не будет никаких. Выполняем то же самое. gitmarch – неуапит. Мы видим, что в этом случае git открыл почему-то текстовый редактор, для того, чтобы нам внести сюда комит мэсыч. И причем по молчанию он предлагает ввести вот такой мёртв мёртв мёртв мёртв мёртв мёртв. Ну, хорошо, сохраняем изменения 2.0x и нажимаем это. Давайте посмотрим теперь историю изменений. Вот он наш последний комит, вот это сообщение мёртв мёртв мёртв мёртв мёртв мёртв мёртв мёртв мёртв мёртв. Обратите, пожалуйста, внимание, у нас у этого комита появилась поле мёртв. И вот здесь у нас указано 2 х суммы. Помните, мы говорили, что они имеют фиксированную длину. Да, совершенно верно. И в данном случае это не означает, что х суммы каким-то волшебным образом сократились. Нет, просто гид для того, чтобы не писать здесь 2 довольно таки длинные строки, он её сокращает. Для удобства, скажем так. И обратите внимание, в этом поле мёртв, указано 2 х суммы. И если внимательно посмотреть, то вот это х сумма. Первое – она соответствует вот этому комитму. А вот это х сумма соответствует вот этому комитму. Выходит, что вот этот комит селается на 2 предыдущих места одного. Да, совершенно верно. Давайте разбираться. Так как мы не можем просто так передвинуть указатель ветки мастера, по сути, самый логичный способ обвинить ветки – это создать ещё один комит, который будет ссылаться на 2 других комитта, на которой указывали ветки мастер и не вапи. Этот комит называется «комитом слияния» или «мёрч-комит». Теперь указатель ветки мастер с месис Хэнн, пережать на него, и история выглядит вот так. Результат – все изменения из неупик, теперь есть и в мастер. Если ветка неупи, больше не нужна, её можно удалить. Git branch – минус дим – неупи. А можно не удалять, а дальше вести разработку, потом снова смёрыть изменения в мастер. То есть, делает они один раз, а столько сколько понадобится. Тут есть важный нюанс. Сейчас мёрч-к прошёл довольно-таки гладко. Git по сути сделал всё сам. На практике же очень часто бывает такая ситуация, когда пример же получается так называемые «мёрч-конфликты». Что это такое и как их решать, мы обязательно поговорим, когда перейдём к сцедрер разработки. А вот сейчас давайте поговорим в оточу. Помните, я говорил, что с помощью системы контроля версии мы можем откатить состояние нашего проекта на любой комитв истории. Как это можно сделать? Помните, как мы создавали ветки? Мы вы сначала выполняли Git branch, неупи, например, а потом выполняли Git checkout, неупи. То есть, переходили на эту ветку. Так вот, в качестве аргумента команда checkout можно передать не только имя какой-то ветки, но ещё и hash sumу какого-то комита. Например, вот так. В этом случае произойдёт. Во-первых, перемещение указать для «это-науказный комитт». Во-вторых, состояние файла в рабочем каталоге будет точно соответствовать этому комитту, то есть, не будет правой окизать этих комиттов. В третьих, мы никак не трогаем указатель веток. В четвертых, если выполнить команду Git status, то получится так называемое состояние «deteched head», когда указатель «head» не указывает ни на одну из веток. Дело в том, что если в таком состоянии начать делать какие-то комиты и потом переключиться на ветку «мастер», например, то вот этот комитт останется как бы потерянным. Он никуда не удалится, но вот вернуться к нему можно будет только знаю hash sum, что вы весьма неудобно. Кстати, раз уж заговорили про команду checkout, то стоит сказать, что с помощью нее можно создавать ветки. Если выполнить команду Git checkout minus b dev, то Git создаст ветку и переместит «head» на нее. По сути, эта команда заменяет две. Git branch dev и Git checkout dev. Если вы хотите это вести новую ветку от другого комита, а не от того, на котором находитесь, то можно в конце передать, например, hash sum у этого комита. Например, вот так. Git checkout minus b, new branch и дальше hash sum у этого комита. Но это не все. Если вы находитесь на какой-то ветке, сделали изменение файли, например, main java, и затем понимаете, что эти правки они ошибочны, их нужно откатить. Вы можете выполнить команду Git checkout и передать имя этого файла, main.java. В результате выполнения состояния файла вернется на состояние последнего комита в этой ветке. Ну, то есть, по сути, вы отметите свои правки. Это, кстати, аналог git reset, вот команды, которые мы не так намно рассматривали. Но самое главное, обратите внимание, когда мы выполняем команду Git checkout, мы никоим образом не меняем указатель веток. То есть, они как были на своих комитах так остались. Мы лишь перемещаем head-по истории. Да, конечно, вместе с этим меняем на состояние файла в рабочем каталоге. Но если все-таки нам нужно переставить указатель именно веток, то для этого есть другая команда, которая называется git reset. Она, скажем так, более опасная. Я, если и выполняет эту команду, то всегда с параметром минус-минус-харт. Он означает следующее, что если вы, например, сделали какие-то правки, возможно, даже что-то добавили в индекс, то, когда вы выполните git reset минус-минус-харт и передадите head-sum, какого-то другого комита, в результате ваши правки все прогонарируются и указатель текущей ветки, на которой вы находитесь. Будет смещен на комит, хэш-суму которого вы указали. Выполняем git reset минус-харт и передаем head-sum. В результате указатель ветки вместе с head-пенемистится, состояние файла в рабочем каталоге перейдет на состояние указанного комита, а вот эти комиты больше не будут видны в истории изменений. Может показаться, что они вообще удалятся, но это не так. В git вообще сложно стота потерять, если это было закамечено, что, кстати, очень здорово. Если вы запомнили head-sum последнего комита, то можно также перемесить указатель ветки на него. А если нет, то даже в этой ситуации можно все поправить. Эту ситуацию я подробно описал в подъеке, поэтому досмотрите и выпусда конца, а мы идем дальше. Все, что мы делали до этого, это выполняли команды на 2-шемлокальном репозиторе. Пора поговорить о том, как мы можем взаимодействовать другими разработчиками. Давайте сейчас пока посмотрим на этот процесс в общем. Обычно для взаимодействия выбирают какой-то центральный сервер. Один с популярных это git hub. Там вы можете держать свой код в виде публичного репозитория, который будет доступен всем, достаточно просто ссылка поделиться. Либо в виде приватного репозитория. Код в таком репозиторе будет доступен вам. И если настроить то, какому-то узкому кругу лица. Бо каких-то крупных компаний внутри своей закрытой сети могут быть другие сервера, например, git hub. Но механизм заимодействия от этого никак не меняется. Зачем вообще нужен какой-то центральный сервер, если мы говорили, что git – это распределенная система, и она не нуждается в какие-то странные серверы. Да, конечно. Гитт этот распределенный систем вы можете работать локального себя, пожалуйста. Но наличие такого сервера дает вам дополнительные плюшки. А именно вы можете там на сервере удобно просматривать какую-то историю комитов. Вы можете удобно просматривать сам комит, что было в нем изменено. Вы можете настраивать там доступ, кто может выполнять какие-то команды на репозиториям, кто не может, кто может иметь к моему доступ, кто не может. Также вы там можете проводить, например, прям на UI, прям в браузере, мёрч каких-то вето, к и так далее. Плюс ко всему это как минимум дополнительный backup. К такому серверу можно подключить какие-то автоматизированные системы, которые будут регулярно на основе вашего кода собирать докер образ, например. Кстати, если вы еще не знакомы с докер, то рекомендую посмотреть после этого выпуска, выпуск продокер у меня на канале. Ссылка есть в описании. Так вот, для того, чтобы нам взаимодействия с другими разработчиками, чаще всего выбирают центральный сервер. Если посмотреть с высока, то механизм взаимодействия с таким сервером выглядит следующим образом. Вот удаленный сервер, а вот два программиста, которые одновременно работают над одним проектом. Они подключаются к серверу и один раз забирают себе полную копию репозитория. Со всей истории делают так называемый клон. Теперь они оба могут отвести каждый свою веку под свою задачу, отмастер, например, и начать работу. Когда кто-то из них закончит, он может отправить измелья на сервер. Причем делать он это может хоть раз в конце рабочего дня, хоть каждый раз прийдь комитем. Как ему удобно. У вас может возникнуть вопрос. Если один разработчик смёжет ветку мастер со своей, и затем запушит или отправит измени� на сервер, то выходит, что у второго будет ветка мастер без его комиток? Да, всё верно. И для того, чтобы он также получил комит и второго разработчика, он может выполнить пул. И тогда у него будет две абсолютно одинаковые ветки мастер. Вот так всё выглядит в теории. Возможно, у вас уже появились какие-то вопросы. Не переживайте, потому что сейчас мы на практике всё разберём. Смотрите, я подготовил себя локально. Вот такой проект, который называется девайс-мониторинг, кстати, разбор этого сервиса был у меня на канале. Ссылка есть в описании. Его мы будем использовать, как пример. И для начала нам нужно создать вообще репозиторий на GitHub. Регистрация здесь довольно-таки просто, на ней становится не буду. Далее можно зайти в раздел ваших репозиторий и нажать здесь кнопочку U. То есть мы таким образом добавляем новый репозиторий. Давайте назовём его как-то. Кстати, обратите внимание, нам говорят, что пробелы будут заменены вот таким узнаком тиры. Здесь можно добавить какое-то описание и смотрите, можно выбрать тип. Будет опублично репозиторий или приватный. Пусть он будет публично. Теперь смотрите, мы можем здесь добавить файл-ридмий. Ридмий это файл со специально разметкой. Если добавить такой файл, то когда мы зайдём на репозиторий на GitHub, то там будет отображаться некоторые информации. Но, соответственно, то, что вы вне сёте. Например, что это за репозиторий, что делает этот код, там, как его используют и так далее. Возможно, ссылки какие-то. Мы сейчас добавляет этот файл не будем. Дальше мы здесь же обратите внимание, мы можем сразу в репозитории добавить гитт-эгнор. И здесь есть масса темплеитоф. Он, например, есть темплеи для джавы, есть для го, есть для парито, нанообщем для многих языков. Но сейчас мы добавлять ничего не будем. Ну и плюс ещё можно выбрать лицензию. Если необходимо, нажимаем Create. Мы создали репозиторию, но теперь возникает логичный вопрос. А как нам теперь связать то, что у нас есть локально с тем, что мы только что сделали? На самом деле всё довольно просто. Нам нужен всего лишь адрес теперь этого репозитория. Но здесь обратите внимание, мы можем выбрать две опции. Это SSH и есть ТДПС. В чём разница? Если мы будем использовать ТПС, то при подключении GitHub, нам нужно будет вести логины пароль. Если же мы будем использовать SSH протокол, то делать этого не нужно будет. Но нужно будет сделать дополнительную настройку на вашем компьютере. Сейчас я не буду на этом останавливаться. Я это очень подробно со скрешотом и пояснениеми оставил в PD. Забегая вперёд, хочу сказать, что по возможности всегда используйте SSH протокол. Вот. Сейчас же, для примера, чтобы нам не останавливаться, вы можете использовать SSH и SSH. Я же выберу SSH. Копируем вот эту ссылочку. Переходим теперь наш локальной репозиторий. Здесь есть всего лишь один комитт. И выполняем здесь к простую команду. GitHub Remote, Ed, Origin и далее вставляем ссылку, которую мы получили с GitHub. Что это такое? GitHub Remote – это команда, которая в принципе управляет удалёнными серверами. То есть, там можно, с вымышей командой, добавлять удалённые сервера, переменовывать их, удалять и так далее. Параметр Ed говорит сам за себя, то есть мы добавляем что-то. Далее я указываю имя удалённого сервер и адрес. Origin – это некоторое устоявшееся уже имя репозитория, если он у вас один в проекте. Выполняем эту команду, и сейчас у нас произошло, по сути, ну мало что изменилось. Для того, чтобы посмотреть, какие у нас в принципе есть репозитории, можно выполнить команду GitHub Remote. И передать ей параметр минус вид, то есть будет более подробный вывод. И смотрите, что получается, мы добавили вроде бы как один репозиторий, а их тут почему-то два. Дело в том, что здесь указан один репозиторий для очтения fetch, а другой репозиторий для того, чтобы отправлять изменение push. Сейчас мы хотим отправить наши локальные изменения в удалённые репозитории. Поэтому выполняем команду GitHub Push Origin Master. То есть я говорю, отправить изменение GitHub Push, куда на сервер Origin в ветку Master, светки, на которой я сейчас нахожусь. Выполняем эту команду. Готово, давайте теперь перейдём в нашей позиторе, обновим страницу и посмотрим, что у нас произошло. А произошло на что, что мы передали наш ход, здесь он теперь хранится в репозиторе, и у нас есть один комит. Вот он и нит. Если мы его откроем, то мы увидим изменение, которые произошли в рамках этого комита. Ну, здесь, по сути, у нас лишь добавление файлов. То есть правок здесь, по сути, нет никаких, только лишь добавление новых файлов. Вот мы создали репозиторий, даже запушали туда какую-то информацию. Вопрос, как теперь этот код передать другому разработчику, если вы планируете вместе работать? Во-первых, если у вас репозиторий публичный, достаточно просто передать ему ссылку и далее выполнить те команды, которых мы сейчас будем говорить. Если же у вас репозиторий приватный, тогда вы должны пригласить людей ваш репозиторий, для того, чтобы они смогли там что-то вообще делать. Для этого нужно перейти в сеттингс, менеджак сесс, и здесь пригласить новую человека по почте, либо по юзернейму. Но возвращаемся к вопросу, как теперь другому разработчику получить код себе на компьютер локальный, до того, что по-надальшему работать. Вот здесь в репозиторе есть кнопка код, если ее нажать, то мы можем опять получить вот эту ссылку, либо STTS, либо SSH. Я выберу SSH, копирую эту ссылку, теперь я открою новую окно терминалам. Если же у вас винтов, то вы в любой папке, опять же нажимаете правой кнопкой, и выбирайте gitbush.k И ведусь команду gitclon и дальше вставляю ссылочку выполниваем. И у нас появилась новая папка, вот таким вот названием, ну, посмотри, как название репозитория, переходим в нее, и смотрите, у нас здесь, по сути, такие же комиты, тот же самый код. То есть, смотрите, у меня сейчас открыто 2 окна терминала, две разные папки, для того, чтобы я мог самотировать работу двух разработчиков. Это первый разработчик, это второй разработчик. Теперь я могу, как второй разработчик уже, ну, например, изменить что-то в каком-то файле. Давайте изменим, например, вот здесь порт на 4-8. gitcomit-am. И дальше вожу какой-то комитмазчик. Да. Теперь у меня в комитах появился новый комит. И теперь я также могу взять и отправить свои изменения на сервер. Делаю gitbush origin master. Все, правки, правильно. Но обратите внимание, я же везет здесь, как второй разработчик я же не указывал. В ремолуд ничего. А дело в том, что если я выполнил сейчас эту команду, gitbush, винус в вид, то здесь уже будет прописан адрес сервера, почему? Потому что мы, когда кланировали, мы же ведь указали откуда кланируем. Поэтому git за нас любезно прописал эти сразу же сервера. Хорошо. Второй разработчик отправил свои правки на сервер. И если мы обонами в страничку, мы увидим, что у нас теперь в позиторе уже 2 комита. Вот он второй наш. Последнее, здесь мы увидим, что произошло изменение. То есть вот эта строка поменялась на такую конкретно, не был заменен порт в данном случае. Но возникает вопрос, как первому разработчику получаете эти правки, ведь у него их нет. Для этого ему нужно выполнить команду gitbush origin master. Мы обязательно подробно, по-позже рассмотрим, что делали эта команда, пока что для простой понимания давайте запомним, что она просто берет и забирает изменения с удаленного сервера. Все, мы видим, что прилетели какие-то изменения. Он файл раны саж, если я теперь веду gitlog, то вижу, что есть этот комитт. И если я открою этот файл раны саж, то я уверен, что да, порт изменился на 4-8. Но вы заметили, сейчас я делал все последовательно. Первый разработчик. Сделал какие-то изменения, запушил их на сервер. Второй получил. Второй сделал какие-то изменения, запушил их на сервер, первый разработчик их забрал. Но чтобы в следующей ситуации, если у нас, например, есть два разработчика, у них локально пока что абсолютно на коварьпозиторию, у них ветка мастера указывает на один и тот же комитт. И они начинают работу. Один делает свои комитты и второй делает свои комитты. И тут они пытаются одновременно запушить свои правки на сервер. Это далеко не выдумано ситуации, потому что иногда, бывает сложный задачик, который хорошо параллелится, отводится одна ветка, и мне и работают на при несколько людей. Давайте посмотрим, что будет в этой ситуации. Вот он разработчик один. Давайте мы здесь поправим application.py, например, внесем какие-то правки, не важно какие, комитим, и теперь второй разработчик, пусть он изменит что-то файли констант, например. Да, пусть будет у нас с большой буквы состояния. Сохраняем. Теперь первый разработчик выполняет пуш. GitPush Origin Master. Все прошло. Мы это уже делали, поэтому ничего удивительно. История, значит, выглядит теперь вот так. Последний комитт Refactory. У этого разработчика, свои комитты, у них общий только Ченчport, а дальше пошли какие-то свои. Теперь он выполняет GitPush Origin Master. Обратите внимание, GitPull перед этим, я не делаю. У нас появилась какая-то ошибка. Ну, собственно говоря, у нас запушить не получилось. И здесь есть у нас подсказка, который говорит, что наше обновление было отклонено, потому что удаленно сервер содержит какие-то правки, которых нет у нас локально. Логично, здесь есть какие-то правки, которые сделал первый разработчик. И он нам предлагает вообще-то сделать GitPull перед этим. Ну давайте попробуем GitPull. У нас, почему-то смотреть, что получилось. Выполняю GitPull, Git открыл. Текстовый редактор для того, чтобы нам ввести комитмастер. То есть он создал какой-то комит. Причем это мёртвый комитм. Ну хорошо, давайте сделаем... Давайте сохраним этот документ. Выполним GitPush, может теперь получится Origin Master. И смотрите, действительно, Пуш прошел. Если мы откроем нашей позитории, то мы увидим, что здесь у нас целых 5 комитов. И смотрите, вот они комиты от первого разработчика, второго, и дальше у нас какой-то мёртвый комитм появился. Вопрос. Что вообще произошло? Для того, чтобы нам разобраться в этом, нужно сначала понять, как устроена Git работа с удалёнными репозиториями. Давайте немножечко отмотаем назад и будем разбираться. Вот нашей позитории, выполняем команду Git Remote, Ed Origin и дальше ссылку. Пока что ничего не меняется, но вот мы делаем GitPush Origin Master. Напоминаю в пустой удалённой репозиторе, там ещё ничего нет. В этот момент помимо того, что на удалённый сервер придётся код и создается новая ветка мастерта. У вас, локально, появляется новую указатель ветки, который имеет вид Remote Slash Origin Slash Master. Его называют «веткослежение» или «Remold Traference». В отличие от ваших локальных указателей, веток, этот указатель, мы не можем никак перемещать. Он нужен для того, чтобы понимать, на каком комите сейчас находятся указатель ветки в удалённом репозитории. Хорошо, история комитов меняется, каким тогда образом передвигается вот этот указатель. Очень просто для того, чтобы получить актуальную информацию с состоянию удалённых веток, можно выполнить команду GitFetch. Если у вас несколько удалённых репозитория, то можно передать как параметри его имя. GitFetch Origin. В результате того действия, обращая внимание с вашими локальными указательными веток, произойдёт ничего. Этим вы лишь обновить и веткислежения. То есть, если кто-то сделал пуш в ветку, то когда вы выполните GitFetch, в этот момент Git скачает недостающие комиты и передвинет веткислежения. Хорошо, а как тогда мне увидите эти комиты у себя в локально ветки? Да просто взять и выполнить мёрж своей локально-ветки с удалённой. Причём обратите внимание, произошёл фаст Форвард. Указатель Мастер просто переехал вперёд без какого-то мёрча комиты. И самое интересное, помните команду GitPool, которому использовать для того, чтобы забрать изменение судорённого сервера? Так вот, внутри, по сути, она выполнает вот эти две команды. GitFetch и GitMёрч. А что произошло в нашей ситуации с двумя разработчиками? В начале у них была абсолютно одинаковая история. У каждого из них локально указатель ветки Мастер стоял на одном и том же комите. И на удалённом сервере Мастер стоял на этом же комите. Начнём с перв GentProfильниками разработчикам. Вот он делает комит – указатель Мастер переезжает вперёд. Чтобы отправить изменение на сервер, он затем делает GitPoŨ. В этот момент сервер принимает его комиты, передвигает Мастер вперёд, а у этого разработчика occasionally удалённую ветку Мастер также переезжают вперёд. Почему? В данном случае, сервер принял прав scalarую первую разработчикам? Для простой понимания возможно сказать так, Если сервер получит вашей правки, может просто передвинуть указатель верки вперед на вашу новое комитт. То он примитый и сделает при этом фастфурвард. В противном случае, если требуется какой-то мёрч, сервер отклонит вашей правки. Если пока что-то не понятно, не переживайте, потому что сейчас мы этот вариант разберём на примере. Переходим к второму разработчику. Он ничего не знает о том, что первый уже сделал какие-то правки и запушил их на сервер. Он делает свои изменения, добавляет новый комитт. Теперь пробует запушить эти правки на сервер, выполняя гид-пуш. Как мы помним сервер в этой ситуации отклонила его комиты. Почему? А смотрите, если сервер примитый, то он не сможет просто передвинуть указатель верки вперед. Хорошо, после неудачного пуш, разработчик делает гид-пугл. И почему-то гид-подложил создать мёрчь комитт? Почему? Давайте разложим эту команду на две. Первая гид-фэдж. Этой команда разработчик получает актуальную информацию об указателях на удалённом репозитории. В результате, он получит примерно такую историю себя локально. Вот этот комитт – это комит первого разработчика, который первым успел запушить изменения. Вторая часть команда гид-пул – это гид-мёрчь. Мы знаем, что в такой ситуации, так как мы не можем просто передвинуть указатель верки вперед, гид будет сделать мёрчь комитт. В результате, история будет иметь вот такой вид. Теперь разработчик пробует делать гид-пуш, и в этой ситуации сервер примит его изменения, так как он может просто передвинуть указатель верки вперед. Кстати, для того, чтобы не писать каждый раз гид-пуш Origin Master, можно выполнить вот такую команду. Гид-пуш минус-минус-эта по-бстрим Origin Master. Один раз в результате гид, что сделать, он связет в вашу локальную ветку. Мастер – с удалённой веткой в Origin. И потом в дальнейший. Можно будет просто выполнять команду гид-пуш, находясь на ветке Мастер. Таким образом, гид будет понимать, что если вы делаете пуш, находясь на ветке Мастер, то есть мне нужно отправить в Origin Master. А ещё у вас мог возникнуть вопрос. Например, кто-то другой разработчик отвёл в ветку, сделал там какие-то кометы и запушил их. И вы теперь по прошествии какое-то времени хотите подключиться к нему, подключиться к работе. Как вам забрать в эту ветку? У вас локально её нету. Нужно локального себя её создавать? Нет, не нужно. Дело в том, что когда вы делаете гид-пу, гид при этом обновляет список удалённых веток, которые есть на удалённом репозиторе. И дальше, смотрите какой нюанс. Предположим, разработчик отвёл ветку девелоп. Он её запушил. Вы просто делаете у себя гид-пу и гид автоматически запомни, что на удалённом сервере Origin есть ветка девел. Но локально он вам её не создаст. Для того, чтобы вам локально перейти на эту ветку, создать по сути, да, переключиться на нёр. Вам нужно просто выплатить команду гид-чекаут девелоп. И смысл в том, что если гид увидит, что у него в записях есть, что в Origin есть ветка девела. Ага, он, значит, вам создать локально ветку и свяжет её с удалённой, которая находится в Origin в девелопе. Вот так всё просто. Гид-чекаут девелоп. Возвращаемся к нашим вопросам. В результате оба разработчика запушли свои правки. Вроде бы всё хорошо, на это можно успокоиться. Но вы заметили, что история теперь она стала нелинейной, когда комиты один за один идут друг за другом. А появились вот эти мерщи комиты, которые ссылаются на два и более. Это нехорошо неплохо, это так есть. Но, честно говоря, мне больше нравится видеть прямоленную историю, когда комиты идут ровно один за одним. Если, конечно, вообще это возможно. Давайте вообще по фантазируем. Можем ли мы как-то убрать вот это витвление? Вернёмся на исходную. Наша история выглядит вот так, после того, как мы выполняли Гид-фэдж. А что если взять этот комит, оторвать его отсюда и приклеить после этого комита? У него однозначно должен поменяться Хэш, это произойдёт как минимум потому, что у него изменится поля Пэрэн, родительский комит. Ведь мы знаем, что если вы сходны последовательности, поменять хотя бы один бит, результат изменится кардинально. При том сами правки никак не поменяются, конечно же. Теперь нам ничего не мешает взять и запушить это всё на сервер, а тут примет эти правки. И хотя мы сейчас и фантазировали, на самом деле тако механизм есть и называется он Гид-Ребейс. Если и попробовать перевести на русский, то это означает перебазирование. Но смотрите, действительно мы берём комиты и перебазируем их куда-то в другое место. Так можно делать, например, и с двумя локальными ветками. Вот тут у нас есть две ветки – мастер и неапи. Задача сделает так, чтобы новое изменение из мастер попали неапи. При этом желательно не делать мёртвчикомит. Для этого, находясь на неуапи, выполняем Гид-Ребейс мастер. Первым делом Гид найдёт комит, который будет являться общим родителям для обойфветок. В данном случае это вот этот комит. Теперь Гид вычислить комиты, которая нужно перебазировать. Он понимает, что в мастер не хватает вот этих комиток. И далее по очереди он начал перемещать их поверх мастер. Перемести в первый комит, Гид сразу же переместит хэд и неуапи на него. При этом, как видим, хэш-комита изменился. А затем следующий. И так далее, пока все комиты не будут перемещены. Может показаться, что вот эти два серых комита удалились, но это не совсем так. Гид вообще сложно что-то удалить, если это было закамечено. На самом деле, они также стали все репозитории. Единственное, них не ссылается неодноведка, поэтому как-то перейти на них можно только зная хэш. Ну и конечно припуши, они не попадут в репозиторию удалённой, потому что не являются частью какой-то ветки. Гид Ребейс – это очень классный инструмент, но он не лишен недостатков. Возможно, вы уже догадались. Представьте, вы работаете в свои ветки и уже запушили комитана сервер. То есть там появился указатель Origin, New App. А теперь выберете и делайте Ребейс. При этом получайте вот такую картину. Если в такой ситуации попробовать сделать гид-пуш, то это будет кланиного сервера, ведь у него указатель стоит на этом комите. И приня в ваши правки, он не сможет просто переместить его вперед. Это можно поправить, но я сразу говорю, что то, что я буду дальше рассказывать, нужно делать максимально осознанно, особенно если в данной ветке работаете не только вы, но ещё и другие разработчики. Если сделать пуш с параметром Force – F, то сервер такой скажет, а тут серьезные люди пушат по этому какие-то вопросы. Ничего страшного, что у меня история другая перепишем. И сервер просто напросто перепишет историю в этой ветке. И она будет точности повторять вашу локальную ветку. Тут вы должны понимать, что если сделать подобные ветки, в которые работают ещё и другие разработчики, и при этом они уже сделали гид-пул, то изобрали себе последнее изменение. То в следующий раз, когда они сделают гид-пул, они вам благодарности не напишут, потому что у них всё равно в результате возник вот эту мёрчиками. Чтобы наверняка защитить некоторые важные ветки, ну например, мастера, от подобных вещей в гид-хабе, можно создать некоторое правило для веток. Переходим в настройки в раздел веток. Здесь есть так называемый протекшен ру и в принципе нам говорят, что определить и какие-нибудь протекшен ру и для того, чтобы как минимум отключить функцию форс-пуша. Ну давайте нажмём и дру. И здесь нам нужно ввести так называемый branch name pattern. Это не означает, что мы здесь должны ввести какую-то конкретную ветку. Мы здесь можем использовать паттерные, которые по сути представляют собой некоторые регулярные выражения. Я в данном случае веду просто имя ветки, потому что вот такой pattern master абсолютно точно попадает по дветку мастер. Логично, да? И здесь я даже в принципе выбирать ничего не буду, я просто нажму кнопочку CREATE. И мы видим, что у нас подвод этот паттер попала одна ветка, которая так называется master. И вот теперь, если даже кто-то попытается сделать форс-пуш в мастер, то ничего не выйдет, потому что сервер не примет эти правки. Кстати, по поводу ветки master. Помните, я говорил, что в мастере как правило хранят кот, который оттестирован, который стабилизирован полностью рабочий. Так вот иногда хочется некоторое момент разработки зафиксировать, но например, релезь. Так вот, в GT есть такой механизм, который называется GTEC. Метки. По сути, мы можем на какой-то комитт оставить какую-то меточку, сообщением, скажем так. В GT есть два типа тегов. Это аннотированные и легковестные. Легковестные теги представляют собой, по сути, просто указатель, имя которого убираете вы. Аннотированные же теги, это полноценные объекты в GT, у них есть hash summa и есть еще автор этого тега, да, так как он был сделанный, так далее. Там куча еще полезной информации. Для того, чтобы создать легковестный тек, на текущем комите, можно выполнить команду GTEC, ну и дальше на приводи. А вот для того, чтобы создать аннотированный тек, можно выполнить команду GTEC минус A, дальше как-то назвать его, например, 20-20, релезь 20-20 точек 4 и можно еще оставить какое-то сообщение. Для того, чтобы вообще посмотреть, какие у нас есть теги, можно выполнить команду просто GTEC и мы видим, что у нас есть 2 теги. Важно, замечание, когда мы делаем пуш, ну, наших изменений каких-то, то теги по молчанию не отправляются на сервер, для того, чтобы нам отправить теги на сервер удаленно, нам нужно сделать это явно, то есть GT Пуш Origin, В1, например, либо можно выполнить команду GT Пуш минус-минус-текс и в результате вообще все теги, которые у нас есть, они отправятся на сервер. Просмотреть теги, можно также на GTHubby, то есть переходим в нашей пасситуре, обновляем страничку, увидим, что у нас есть 2 тега, вот он в1 и вот он тег, которые мы создавали. У него есть еще такое короткое сообщение. Теперь давайте рассмотрим, как можно работать с GTом в среде разработки. Я буду использовать по ичарн, это раз среда разработки для петона. Есть еще интеридж-ид для джавы, и в плане взаимодействия с GTом, там нет никакой разницы. Давайте мы сейчас рассмотрим первый случай, то есть мы создаем новый проект, как-то его называем, да. Здесь уже есть какой-то файл-мейн.пай, который по ичарам, видимо, сам создал, можно запустить, и вот здесь по всей видимости, да, он просто выведет хай-пай-чарм. Ну вот представьте, вы работали над каким-то проектом, да, и в какой-то момент захотели подключить систему контраю версии, если не сделали это еще раньше. Как это можно сделать? Вверху есть раздел, который называется VCS, выбираем его, и здесь есть пункт Enable Version Control Integration. Здесь выбираем Git, нажимаем OK, и как нам можно теперь добавить сюда удаленные какие-то репозитории. Ну, во-первых, можно опять же перейти в раздел VCS, здесь появилось у нас, появился раздел Git, и здесь есть Remote. Как видим, здесь пусто, потому что мы ничего не добавляли, да, но можем нажать кнопочку, и сюда добавить УРЛ, HTTP, с либо там SSH, да, какой-то нажима, нажать кнопочку OK, и он у вас появится. Это первый вариант, когда вы начинаете разрабатывать проект, вот с нуля, да, давайте теперь рассмотрим вариант, когда вы подключаетесь к проекту, то есть репозиторий уже есть на Git Lab, либо на Git Hub, как вам подключится к работе. Ну, нам нужна ссылочка, да, копируем ее, и выбираем вот этот пункт Git from Version Control. Вставляем сюда ссылку, Git смотрите самым предлевым папчику, вот он наш проект, если посмотреть вот в разделе VCS, во-первых, у нас тут есть уже пункт Git, и в Remote, обратите внимание, у нас есть уже Origin, то есть один из серверов у нас уже есть. Внизу у нас, во-первых, справа отображается текущая ветка, вот она мастер, здесь у нас есть ветки, которые есть на удаленных серверах, и наши локальные. Можно здесь создать новую ветку, например, вести название ветки, девелоп, и можно сразу же поставить галочку, например, перенетит эту ветку, либо нет, поставим эту галочку, нажимаем CREATE, и смотрите в результате, мы сейчас находимся, как здесь видно, на ветке девелоп уже. Переключиться обратно на ветку мастер, можно, опять же, просто выбираем ее, выбираем checkout, все, мы на ветке мастер. Внизу у вас здесь вот разделя Git, у нас этоображается, ну, какая-то информация, которая связана с Gitом непосредственно, мы разделили лок, например, мы видим все комиты, обратите, кстати, внимание на вот эту вот историю, здесь у нас есть мёртвый комитт, и история выглядит у нас сейчас вот так не линейно. Здесь можно отфильтровать, например, по веткам, то есть здесь будут отображаться комиты, которые, во всех ветках, которые относятся только к хеду, или, например, вести какую-то ветку конкретную, и будут отображаться в ветке комиты, которые относятся только к этой ветке. Я выберу, можно также еще выбрать фильтрацию по юзеру, например, мои комиты, либо выбрать какого-то другого пользователя. Ну, в общем, здесь можно как-то отфильтровать комиты, да? Дальше, если мы перейдем на какой-то комитт, нажмем на него, то справа у нас отобразится некоторые полезные информации. Во-первых, кто сделает комитт его хэшсума? Да, точнее, часть хэшсума. И мэл пользователя дата, и какие файлы были изменены в рамках этого комита. Если нажмувание на файу два раза, то откроется вот такой окошечка, которая мне покажет, ну, по сути, див разницу, что было и что стало. Я сразу вот вижу, что в рамках того комита была изменена эта строка, а конкретно, вот поичарм подсвечивает, что был изменен вот этот символ. И так для каждого комита, например, вот Changeport был изменен рано саша. Открываем, смотрим, что у нас изменился port 8080 на 4.8. Еще одна очень интересная штука. Если я, например, добавляю какой-то файл, давайте прям здесь создадим ServicePy. Git нам сразу предлагает его добавить в индекс или нет. Прям сразу же. Если я, например, нажму кнопочку Ed, то обратите внимание, File стал зеленым. Это говорит о том, что File у нас попал в индекс. Если же, например, я не буду добавлять его в индекс, то есть это просто будет на у вас созданный File. ServicePy. Да, я не буду добавлять в индекс. File будет красным. Это означает, что Git его не добавил в индекс. И он вообще у нас вон трект File находится. Для того, чтобы его добавить ручную можно правой кнопкой Git Ed или использовать горячую клавишу. Вот, File у нас снова стал зеленым. Здесь я могу нести какие-то изменения, но давайте, например, импортируем какую-то константу. Да, и просто выведем ее. Да, я могу теперь эти правки закомнить. Как это можно сделать? Во-первых, вы помните, что нужно добавить этот файл опять в индекс, потому что он был добавлен пустым. Я в нее какие-то правки. И вот Пайчарм, чем хорошее, на на случай, что он делает это автоматически. Здесь есть вот такая кнопка comit. Я обычно пользуюсь с читанием горячих клавиши, comandки, либо на виндасе comandка, контролка. Да, нажимаем эту клавишу и Пайчарм автоматически. Сейчас под капотом, скажем так, выполним команду Git Ed для этого файла. Ну и вообще для тех, которые были изменены. Здесь я могу внести какой-то comit-message. Это ServicePy. Нажимаю comit. И смотрите, файл просто стал у нас белым. Дальше, если я, например, файл, это ты изменил как-то. Да, импортируем LineState и онлайнState, я буду говорить. То смотрите, файл стал синим. Это означает то, что в нем что-то было изменено. И плюс к тому же, обратите внимание, что вот здесь вот рядышкам с номером строки появились вот такие вот обозначения. Они говорят не о том, что конкретно эти строки в данной фале были изменены. Более того, если я нажму на них, то я увижу что было конкретно изменено. Смотрите, было у FlyingState, стало онлайн стоит. Я могу нажать сюда, тогда Пайчарм не вернет эту строку, которая была. Я могу теперь также так же так же закомидеть эти правки, нажимаю ComandK, да, ввиду какой-то новый comitMessage. И смотрите, здесь я могу просто закомидеть, я могу выбрать вот этот трегольный чай и сделать сразу comit и push. В результате пайчарма, что сделать, он во-первых, закомить мои изменения и во-вторых, предлорот мне сделать push, удаленый репристорик, уда в Origin, master и отправит он вот эти 2 comit, потому что их там нет. Нажимаем push и у нас эти comit-ы улетели на сервер, да, если мое обнамен страничку, то мы увидим здесь вот эти comit-ы. Возвращаемся в Пайчарм. Если я нажму на вот этой области правой кнопкой мыши и выберу анатейт, то я увижу кто конкретно менял этот файл. Именно, точнее, я увижу здесь пользователя, более того, если я нажму на какую-то изтрог, я увижу во-первых, comit в рамках которого и были внесены эти изменения. И помимо этого файла, если будут в рамках comit-ы меняться, что-то еще, я еще это здесь увижу. Очень, очень удобно, кстати. Теперь, например, я сделал какие-то правки и понимаю, что, наверное, надо их отменить, для того, чтобы вообще отменить все изменения файлы, ну, например, я его вообще удалил. Я могу нажать сюда и выбрать файлы, которые мне необходимо отменить и нажать кнопочку rootback. В результате, у меня состояние этого файла вернется на состояние последнего comit-ы, что весьма и весьма удобно. Также здесь очень удобно работать с мержами вообще и rebase. Вот обратите внимание. У меня сейчас история гита выглядит следующим образом. В ветке master у меня есть два вот этих comit-а. А вот, например, в ветке девилаб, этих comit-ов нет. И, притолжим, я хочу забрать новые изменения из мастера. Как это можно сделать? Давайте рассмотрим на примере rebase. Переходим на ветку девилаб. Теперь выбираем ветку master и выбираем пункт rebase current, он-то select it, то есть rebase текущие ветки на выбранную выбранную мастер. Давайте выполним. Все, в результате, смотрите, мы находимся на ветке девилаб и у нас появились вот эти два comit-а. Я могу теперь сделать пуш. Кстати, для того, чтобы сделать пуш, можно нажать на вот эту вот стрелку. Либо выполнить command shift key, либо control shift key, если Windows. И нажимаю веточку, нажимаю кнопку push. В результате смотрите, у меня на против этого comit-а, во-первых, появился origin divilab. И если я зайду в репозиторе, обновлю страницу, то вот здесь вот этоображается в севетке. Я увижу, что у нас появилась ветка девилаб новая. Если говорить, например, о мерже, то это делается здесь также довольно просто. То есть смотрите, мы, например, хотим забрать изменение из мастера в девилаб. При этом использовать merge. Пожалуйста, вот мы находимся на ветке девилаб, выбираем master и выбираем пункт merge intocard, то есть merge вот это ветки master, вот текущая. Но у нас там ничего не произойдет, потому что ветки указывают надене тот же comit. Но помните, я как-то говорил, что на практике очень часто, пример же, возникают так называемые merge conflict. Мы что-то такое давайте сейчас как раз и рассмотрим. Для этого мне понадобятся две ветки, но в принципе они у нас уже есть. Удевелаб и мастер. Смотрите, переключаемся на мастер. Обращаем внимание, мастер и девилаб сейчас находится на одном и том же comit. Теперь я, давайте поправно, например, вот эту файл, заменю здесь port. Пускай он будет 80-80. Я делаю comit. Да. При этом я не буду пока пушить, просто закамить. Вот здесь в разделе git, я вижу, что появился новый comit. Теперь я переключаюсь на ветку девилаб. Здесь как видите, port остался 4-8. И теперь я поменяю тоже здесь port на какой-нибудь другой, пусть будет 4-5. И также его comit. Пусть будет ченчport. Тоже не буду пушить, я просто закамить. Отлично. То есть смотрите, что я сделал. Я получается в двух разных ветках изменил один и тот же файл. И мало того, что один и тот же файл я изменил еще одну и ту же строку. Да и вообще один и тот же port поменял. Теперь я хочу смержить ветку девилаб с мастером. Для этого перехожу на мастер. Здесь обратите внимание port 80-80. И я мержу ветку девилаб в мастер. Мерч, карант, мерч и т.к. И смотрите, что у нас получилось. Вкрывается вот такой окошко. И в нем перечислены файлы, которые git не смог смержить автоматически. Но давайте его откроем и посмотрим. Здесь насображается вот такой окошко. Смотрите, справа у нас подписаны изменения из девилаба, слева, изменения из мастера и результат. Что у нас будет вообще в результате? Здесь смотрите, он показывает, что конкретно вот в третьей строки он не знает, что делать. То есть был изменен port, но только изменен он по разному. Здесь 4-5 орбки, здесь 80-80. А в итоге то, что мы должны делать, так. Поэтому мы, например, можем принять изменения из ветки мастер, нажав вот таким образом. В результате нас port стал 80-80. Можно, например, отклонить вот эти изменения. То есть нам не надо в 4-5 орбки. А можем, например, ввести свой вариант, ну, например вообще 80-89. Нажимаем кнопочку и плай. И в результате смотрите, что у нас получилось. У нас появился мёрч-комид. И история стала выглядеть вот такой вот не линей. Почему я об этом рассказываю только сейчас? А никогда мы, например, разматривали сам механизм гитмёрч, вроде биологичные вещи. На самом деле, когда вы работаете с реальным проектом и когда вы начинаете мёржать вот так вот ветки, мёрч-конфлекс получается довольно таки, ну, часто. И дело в том, что они получается такими, что это не сейчас, как одна строчка. А там целые куски бкода получаются. И вот разобрать их, особенно если несколько файлов попались вот так вот, да, в консоли консольными инструментами, конечно, можно, но довольно таки неудобно. Лично мне намного удобнее работать в такой ситуации, вот именно среди разработки. Потому что когда у вас получается такая ситуация, вы должны уже думать, как бы головой, да, какой функционал взять, ага, вот здесь вот нужно вот эти паравки взять, а вот здесь нужно это изменить, вот это отклонить и так далее. И в консоли, ну, лично мне, это не совсем удобно делать лучше, все-таки делать среди разработки. И еще смотрите, как можно сделать обрет проекты, то есть делать гитпул. Для этого здесь есть вот такая стрелочка, да, обрет про джик, либо используй горячую клавишу, что намного удобнее. Комант-ти, либо для винда с этой контролтии. И смотрите, если она не у нажму, то мне пощар предлагает. А что мы будем делать с изменениями, которые нам прорядят сервером и будем мержить, или мы будем ребезить. Я всегда стараюсь выбирать ребезли к того, чтобы история была, как можно равнее. Я имих до история комитов. Нажимаем OK, и соответственно, у нас проект будет обновляться. Здесь же можно выполнить команду, гитп чекают и гитрисет. Ну, например, я хочу посмотреть состояние проекта на вот этот вот комит. Да, я выбираю этот комит, правой кнопочкой и выбираю вот этот пункт. И обратите внимание, у нас здесь появился вот такой вот трюгольничек, да, это у нас состояние dtchdhead. И, соответственно, мы видим состояние файлов, но вот этот вот комит. Для того, чтобы снова вернуться на ветку на какую-то выбираем, веточку, выбираем чекают. Если же мне, например, необходимо изменить указатель ветки, то есть выполнить гитрисет. То это также можно здесь делать. Ну, например, выбираем ветку мастер. Я вижу, что OriginMaster указывает на этот комит. И предположим, я чуть решил, что вот эти комитые, наверное, мне не нужны. Ну вот так вот получилось. Для того, чтобы перенести сюда указатель моей локальной ветки мастер, я выбираю этот комит и выбираю ResetCaronBranch.he И выбираю Parameter Heart. Всегда здесь вы можете знакомиться с этими параметрыми. То есть поиграться с ними посмотреть, как будет себя вести в этом случае гит. Нажимая Reset и все. У меня состояние проекта вернулась на этот комит и плюс еще к тому же сама ветка перешла вот на этот комит. И еще я хочу поедиться некоторыми рекомендациями, как пользоваться гитом. Это не какие-то жесткие требования. Это просто некоторая практика, которая я для себя выработал. Ну, первое касается работы в ветках. Никогда не работайте в ветке мастер. Если вам нужно сделать какой-то новый функционал, отведите ветку, закомите туда свои правки. Если нужно сделать несколько комитров, оттестируйте там все и потом уже делайте либо мерщ, либо Ребейс, ваших правок в мастер. В мастер не надо ничего делать. Вторая рекомендация касается комит-мастержев, сообщения в комите. Есть несколько практик. Я для себя выбрал написание текстов в императиве. То есть, когда мы пишем, например, был добавлен файл, вот, аб.пай. Я пишу, ed.app.py. Еще одна практика есть, похожая. Это писать, как бы, в passive-намзологии, например, аб.pile was edit. Ну, то есть был добавлен. Я для себя выбрал императив. По поводу самих комит-мастержев старайтесь сделать их как можно, короче. То есть, конечно, можно писать какие-то длинущие, но стараться нужно писать короткие, но при этом, чтобы они содержали максимально много в себе информации. Для чего? Для того, чтобы когда человек видит эту историю комитов, чтобы он мог спокойно определить, что, ага, в рамках вот этого комита было сделано тота. Даже не открывая вообще этот комит и не смотреть правки. Ну, конечно, сам комит-мастер, чем он должен быть говорящим. То есть, если вы что-то поменяли там, опишите совершенно другие вещи, то так делать, конечно же, не стоит. Ещё на рекомендации ты старайтесь держать вашу историю комитов, как можно более линейный. Ну, например, когда вы делаете пул, сделаете ребейс. Но, но, но, ребейс не нужно использовать тогда, когда вы там, например, забрали изменения с сервера, там, сделали какой-то ребейс, запушили. А до этого из этой жведки другой разработчик забывался в изменении. В результате, когда он сделает пул, он получит вот этот вот мёртвый комит. Это не нужно делать. Делайте ребейс, когда вы, например, забираете правки с сервера и при этом, у вас есть уже свои комиты. Вот тогда ребейс прямо отлично подходит, потому что вы избавляйтесь вот этих вот мёртвых комитов. Теперь по поводу педревки, в выпокредующим выпусками часто писали мне, что было бы здорово иметь какую-то текстовую версию выпуска, ну, какой-то конспект. Сделал педревку, туда вошли. Абсолютно все команды и весь материал из этого пуска, я постарался сделать её максимально интерактивно. То есть многие элементы в ней не кликабельны, вы можете кликать, например, на какие-то пункты переходить на конкретный лист, который содержит себе вот эту команду, либо эту тему, плюс можно вернуться назад. Также те команды, которые рассматривались в этом выпуске, напротив них стоиз ночок такого дютуба. Вы можете на него нажать и, соответственно, переедете прямо на момент вот этого видео, где рассматриваться вот эта команда. Плюс, помимо того, что мы рассматривали здесь на видео, туда я еще включил ряд случаев таких, скажем, но не тривиальных. И команды, соответственно, для их решения. Ну и плюс там еще, конечно же, настройка, с sh для github, там и много-дмного, другое собрал еще. Плюс постарался сделать её, скажем так, приятно и визуально для того, чтобы было удобно ее читать. Получили эту педревку, можно по ссылке в описании, я оставил там ссылочку на Telegram-бота, которого сам написал. Переходите туда, там ее можно получить. Ну и что касается тема гитта, вот все, на этом моменте я завершаю видео, дальше все, что буду говорить, наверное, в гитах уже не будет касаться. А хочу поговорить просто об изменениях на канале, что вообще произошло. Ну, первое нас уже чуть больше 24 тысяч. Понятно дело, что современный ютуб, такими цифрыми, вообще не удивишь, но тем не менее, мне рады то, что у нас формируется вот такое сообщество, с обществом, с обществом людей, который интересно узнавать что-то новое, плюс по обратной связи, по вашим комментариям, по вашим сообщениям, я вижу, что вот эта аудитория, она умная, адекватная аудитория, да? Это очень, очень приятно. Вот, спасибо вам огромное, поэтому пишите комментарии, там вопросы какие-то свои, вот я стараюсь читать, все комментарии, повозможете стараюсь, конечно, отвечать. Вот, плюс что еще изменений? Час написали мне вот особенно под выпуском ProGit, что не хватает визуального сопровождения, да? То есть на голос, там, возможно, точнее на слух, возможно, не так просто воспринимать, да? Поэтому потратил кучу просто времени на то, чтобы сделать вот такие вот интерактивные визуальные ставки, визуально-анимацию в этот выпуск, кое-фь, я надеюсь, вы заметили, было довольно-таки много. Вот, плюс еще звук, вы писали, что есть шум, вот, начал делать первые шаги в этом направлении, во-первых, я заменю петличку, вот, сейчас я пишу на петличку, боя, это последняя версия, вот это активный микрофон и рекордер Zoom, Zoom Edge One, но собственно, я давно не могу уже пользовать, но все-таки, наверное, нужно будет какие-то вопросы сейчас не решить, вот, но первые шаги уже сделаны, петличку заменил, вот, конечно же еще будут новые выпуски, я читаю ваши приложения тем, следующих выпусках, я все читаю, обязательно пишите там своего варианта, если вам что-то интересно, обязательно оставляйте комментарии, оставляйте вопросы свои, там, я, возможно, конечно же, буду стараться отвечать на них, обязательно напишите в вашем нере, попробую вот такого формата, то есть визуальная анимация, да, такой визуальный сопровождение лучше ли это и режествует что-то доработать, вот, мне будет очень интересно почитать, ну что ж, на этом, пожалуй, все, всего вам самого доброго, что ты встречай в этом мире, с вами был Артём, до новых встреч, пока-пока!